---
title: i18n
description: internationalize your docs
order: 9
---

serve documentation in multiple languages.

## folder structure

<Files>
  <Folder name="docs" defaultOpen>
    <Folder name="en" defaultOpen>
      <File name="index.mdx" />
      <File name="getting-started.mdx" />
    </Folder>
    <Folder name="ja">
      <File name="index.mdx" />
      <File name="getting-started.mdx" />
    </Folder>
    <Folder name="zh">
      <File name="index.mdx" />
      <File name="getting-started.mdx" />
    </Folder>
  </Folder>
</Files>

## content loader

create locale-aware content:

```tsx
import { defineContent, z } from "fromsrc"

const locales = ["en", "ja", "zh"] as const

type Locale = typeof locales[number]

export function createLocalizedContent(locale: Locale) {
  return defineContent({
    dir: `docs/${locale}`,
    schema: z.object({
      title: z.string(),
      description: z.string().optional(),
      order: z.number().optional(),
    }),
  })
}

export const en = createLocalizedContent("en")
export const ja = createLocalizedContent("ja")
export const zh = createLocalizedContent("zh")
```

## route structure

use next.js dynamic segments:

<Files>
  <Folder name="app" defaultOpen>
    <Folder name="[locale]" defaultOpen>
      <Folder name="docs" defaultOpen>
        <Folder name="[...slug]" defaultOpen>
          <File name="page.tsx" />
        </Folder>
      </Folder>
    </Folder>
  </Folder>
</Files>

## page component

```tsx
import { notFound } from "next/navigation"
import { en, ja, zh } from "@/lib/content"
import { MDX } from "@/components/mdx"

const content = { en, ja, zh }

interface Props {
  params: Promise<{ locale: string; slug: string[] }>
}

export async function generateStaticParams() {
  const locales = ["en", "ja", "zh"]
  const params = []

  for (const locale of locales) {
    const docs = await content[locale].getAllDocs()
    for (const doc of docs) {
      params.push({ locale, slug: doc.slug })
    }
  }

  return params
}

export default async function DocPage({ params }: Props) {
  const { locale, slug } = await params

  if (!content[locale]) notFound()

  const doc = await content[locale].getDoc(slug)
  if (!doc) notFound()

  return (
    <article>
      <h1>{doc.title}</h1>
      <MDX source={doc.content} />
    </article>
  )
}
```

## locale switcher

```tsx
"use client"

import { usePathname, useRouter } from "next/navigation"

const locales = [
  { code: "en", name: "english" },
  { code: "ja", name: "japanese" },
  { code: "zh", name: "chinese" },
]

export function LocaleSwitcher() {
  const pathname = usePathname()
  const router = useRouter()

  const current = locales.find((l) => pathname.startsWith(`/${l.code}`))

  const switchLocale = (code: string) => {
    const segments = pathname.split("/")
    segments[1] = code
    router.push(segments.join("/"))
  }

  return (
    <select
      value={current?.code || "en"}
      onChange={(e) => switchLocale(e.target.value)}
      className="bg-surface border border-line rounded px-2 py-1 text-sm"
    >
      {locales.map((locale) => (
        <option key={locale.code} value={locale.code}>
          {locale.name}
        </option>
      ))}
    </select>
  )
}
```

## proxy configuration

redirect based on accept-language header:

```tsx
import { NextRequest } from "next/server"

const locales = ["en", "ja", "zh"]
const defaultLocale = "en"

export async function proxy(request: NextRequest) {
  const pathname = request.nextUrl.pathname

  const hasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )

  if (hasLocale) return

  const acceptLanguage = request.headers.get("accept-language") || ""
  const preferred = acceptLanguage.split(",")[0].split("-")[0]
  const locale = locales.includes(preferred) ? preferred : defaultLocale

  return Response.redirect(new URL(`/${locale}${pathname}`, request.url))
}
```

## translations file

store ui strings separately:

```tsx
const translations = {
  en: {
    search: "search",
    toc: "on this page",
    edit: "edit this page",
    prev: "previous",
    next: "next",
  },
  ja: {
    search: "search",
    toc: "contents",
    edit: "edit",
    prev: "back",
    next: "next",
  },
  zh: {
    search: "search",
    toc: "contents",
    edit: "edit",
    prev: "back",
    next: "next",
  },
}

export function useTranslations(locale: string) {
  return translations[locale] || translations.en
}
```

## localized metadata

```tsx
export async function generateMetadata({ params }: Props) {
  const { locale, slug } = await params
  const doc = await content[locale].getDoc(slug)

  return {
    title: doc?.title,
    description: doc?.description,
    alternates: {
      languages: Object.fromEntries(
        locales.map((l) => [l, `/${l}/docs/${slug.join("/")}`])
      ),
    },
  }
}
```

## rtl support

handle right-to-left languages:

```tsx
const rtlLocales = ["ar", "he", "fa"]

export function DocLayout({ locale, children }) {
  const dir = rtlLocales.includes(locale) ? "rtl" : "ltr"

  return (
    <html lang={locale} dir={dir}>
      <body>{children}</body>
    </html>
  )
}
```
